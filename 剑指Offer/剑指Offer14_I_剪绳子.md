## &#127800; 剑指 Offer 14- I. 剪绳子 &#127800;

### &#127826; 题目

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（`m、n`都是整数，`n>1`并且`m>1`），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是`8`时，我们把它剪成长度分别为`2、3、3`的三段，此时得到的最大乘积是`18`。

示例 1：

输入: 2<br>
输出: 1<br>
解释: 2 = 1 + 1, 1 × 1 = 1<br>

示例 2:

输入: 10<br>
输出: 36<br>
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36<br>

提示：
`2 <= n <= 58`

### &#127826; 题解


<details>
<summary>&#127808; 动态规划 &#127808;</summary>

### 思路
这题用动态规划是比较好理解的

- 我们想要求长度为`n`的绳子剪掉后的最大乘积，可以从前面比`n`小的绳子转移而来
- 用一个 **dp数组** 记录从**0到n**长度的绳子剪掉后的最大乘积，也就是`dp[i]`表示长度为`i`的绳子剪成`m`段后的最大乘积，初始化`dp[2] = 1`
- 我们先把绳子剪掉第一段（长度为`j`），如果只剪掉长度为`1`，对最后的乘积无任何增益，所以从长度为`2`开始剪
- 剪了第一段后，剩下`(i - j)`长度**可以剪也可以不剪**。
    - 如果不剪的话长度乘积即为`j * (i - j)`；
    - 如果剪的话长度乘积即为`j * dp[i - j]`。
    - 取两者最大值`max(j * (i - j), j * dp[i - j])`
- 第一段长度j可以取的区间为`[2,i)`，对所有`j`不同的情况取最大值，因此最终`dp[i]`的转移方程为
    - `dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))`
- 最后返回`dp[n]`即可

### 步骤
1. 检测是否访问过、是否到达边界、是否满足数位和小于k值
2. 剪枝测试
3. 修改返回值
4. 进入递归（向下向右走）
```java
class Solution {
    public int cuttingRope(int n) {
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for(int i = 3; i < n + 1; i++){
            for(int j = 2; j < i; j++){
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
}
```
  
</details>
  
  
<details>
<summary> &#127808; 贪心算法 &#127808;</summary>

## 思路
  - 尽可能把绳子分成长度为3的小段，这样乘积最大



## 步骤

- 如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1
- 如果 n == 4，返回4
- 如果 n > 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段
- 以上2和3可以合并


```java
  class Solution:
    def cuttingRope(self, n: int) -> int:
        if n < 4:
            return n - 1
        res = 1
        while n > 4:
            res *=3
            n -= 3
        return res * n
```

</details>

[参考](郁郁雨 "链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-zhi-offer-14-i-jian-sheng-zi-huan-s-xopj/")